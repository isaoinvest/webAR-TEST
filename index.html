<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Video Hologram Effect</title>
    <style>
        body { 
            margin: 0; 
            background: black; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 100;
        }
        #videoInput {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            padding: 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 5px;
        }
        #videoInput input {
            margin-right: 10px;
        }
        #videoInput button {
            padding: 5px 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="loading">Loading...</div>
    <div id="videoInput">
        <input type="file" id="fileInput" accept="video/*">
        <button id="defaultVideo">Use Default Video</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let points, material;
        let animationId;

        // Setup scene, camera, renderer
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Simple orbit controls implementation
        class SimpleOrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3();
                
                this.rotateSpeed = 1.0;
                this.zoomSpeed = 1.2;
                
                this.spherical = new THREE.Spherical();
                this.sphericalDelta = new THREE.Spherical();
                
                this.scale = 1;
                this.panOffset = new THREE.Vector3();
                
                this.mouseDown = false;
                this.mouseX = 0;
                this.mouseY = 0;
                
                this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
                
                this.update();
            }
            
            onMouseDown(event) {
                this.mouseDown = true;
                this.mouseX = event.clientX;
                this.mouseY = event.clientY;
            }
            
            onMouseMove(event) {
                if (!this.mouseDown) return;
                
                const deltaX = event.clientX - this.mouseX;
                const deltaY = event.clientY - this.mouseY;
                
                this.mouseX = event.clientX;
                this.mouseY = event.clientY;
                
                this.sphericalDelta.theta -= deltaX * 0.01 * this.rotateSpeed;
                this.sphericalDelta.phi -= deltaY * 0.01 * this.rotateSpeed;
            }
            
            onMouseUp() {
                this.mouseDown = false;
            }
            
            onMouseWheel(event) {
                if (event.deltaY < 0) {
                    this.scale /= this.zoomSpeed;
                } else {
                    this.scale *= this.zoomSpeed;
                }
            }
            
            update() {
                const offset = new THREE.Vector3();
                const quat = new THREE.Quaternion().setFromUnitVectors(
                    this.camera.up, new THREE.Vector3(0, 1, 0)
                );
                const position = this.camera.position;
                
                offset.copy(position).sub(this.target);
                offset.applyQuaternion(quat);
                
                this.spherical.setFromVector3(offset);
                this.spherical.theta += this.sphericalDelta.theta;
                this.spherical.phi += this.sphericalDelta.phi;
                this.spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, this.spherical.phi));
                this.spherical.radius *= this.scale;
                this.spherical.radius = Math.max(50, Math.min(1000, this.spherical.radius));
                
                offset.setFromSpherical(this.spherical);
                offset.applyQuaternion(quat.invert());
                
                position.copy(this.target).add(offset);
                this.camera.lookAt(this.target);
                
                this.sphericalDelta.theta *= 0.9;
                this.sphericalDelta.phi *= 0.9;
                this.scale = 1;
            }
        }

        controls = new SimpleOrbitControls(camera, renderer.domElement);

        function createHologramEffect(videoElement) {
            // Remove existing points if any
            if (points) {
                scene.remove(points);
                if (points.geometry) points.geometry.dispose();
                if (points.material) points.material.dispose();
            }

            // Particle system parameters
            const width = 256;
            const height = 144;
            const particleCount = width * height;

            // Geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const uvs = new Float32Array(particleCount * 2);

            for (let i = 0; i < width; i++) {
                for (let j = 0; j < height; j++) {
                    const index = j * width + i;
                    positions[index * 3] = (i / width - 0.5) * 400;
                    positions[index * 3 + 1] = (j / height - 0.5) * 225;
                    positions[index * 3 + 2] = 0;

                    uvs[index * 2] = i / (width - 1);
                    uvs[index * 2 + 1] = 1 - j / (height - 1);
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

            // Create video texture
            const videoTexture = new THREE.VideoTexture(videoElement);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.format = THREE.RGBFormat;

            // Shader material
            material = new THREE.ShaderMaterial({
                uniforms: {
                    video: { value: videoTexture },
                    depthScale: { value: 100 },
                    particleSize: { value: 2.0 },
                    time: { value: 0 },
                    curlAmplitude: { value: 20 },
                    curlFrequency: { value: 0.01 },
                    curlSpeed: { value: 0.5 }
                },
                vertexShader: `
                    varying vec3 vColor;
                    uniform sampler2D video;
                    uniform float depthScale;
                    uniform float particleSize;
                    uniform float time;
                    uniform float curlAmplitude;
                    uniform float curlFrequency;
                    uniform float curlSpeed;

                    // Simplified noise function
                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }

                    float noise(vec2 st) {
                        vec2 i = floor(st);
                        vec2 f = fract(st);
                        float a = random(i);
                        float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0));
                        float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                    }

                    void main() {
                        vec4 color = texture2D(video, uv);
                        vColor = color.rgb;
                        
                        // Calculate luminance for depth
                        float luminance = 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;
                        
                        vec3 pos = position;
                        pos.z = -luminance * depthScale;
                        
                        // Add some animated noise displacement
                        float noiseVal = noise(uv * 10.0 + time * curlSpeed);
                        pos.x += sin(time + uv.y * 10.0) * curlAmplitude * noiseVal * 0.1;
                        pos.y += cos(time + uv.x * 10.0) * curlAmplitude * noiseVal * 0.1;
                        pos.z += noiseVal * curlAmplitude * 0.5;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = particleSize * (1.0 + luminance * 0.5);
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        // Create circular points
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(length(coord) > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.4, 0.5, length(coord));
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                depthTest: true,
                blending: THREE.AdditiveBlending
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            // Setup GUI
            if (window.gui) {
                window.gui.destroy();
            }
            
            window.gui = new dat.GUI();
            window.gui.add(material.uniforms.depthScale, 'value', 0, 200, 1).name('Depth Scale');
            window.gui.add(material.uniforms.particleSize, 'value', 0.1, 5, 0.1).name('Particle Size');
            window.gui.add(material.uniforms.curlAmplitude, 'value', 0, 50, 1).name('Curl Amplitude');
            window.gui.add(material.uniforms.curlFrequency, 'value', 0.001, 0.1, 0.001).name('Curl Frequency');
            window.gui.add(material.uniforms.curlSpeed, 'value', 0, 2, 0.1).name('Curl Speed');

            document.getElementById('loading').style.display = 'none';
        }

        // Video setup
        function setupVideo(src) {
            const video = document.createElement('video');
            video.crossOrigin = 'anonymous';
            video.loop = true;
            video.muted = true;
            video.playsInline = true;
            
            video.addEventListener('loadeddata', () => {
                video.play().then(() => {
                    createHologramEffect(video);
                }).catch(err => {
                    console.error('Video play failed:', err);
                    document.getElementById('loading').textContent = 'Click to play video';
                    document.addEventListener('click', () => {
                        video.play();
                        createHologramEffect(video);
                    }, { once: true });
                });
            });

            video.addEventListener('error', (e) => {
                console.error('Video error:', e);
                document.getElementById('loading').textContent = 'Video loading failed. Please try another video.';
            });

            video.src = src;
        }

        // File input handler
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('video/')) {
                const url = URL.createObjectURL(file);
                setupVideo(url);
            }
        });

        // Default video button
        document.getElementById('defaultVideo').addEventListener('click', () => {
            // Using a sample video URL - replace with your video
            setupVideo('https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4');
        });

        camera.position.z = 300;

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            if (material) {
                material.uniforms.time.value = clock.getElapsedTime();
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start with default video
        document.getElementById('loading').textContent = 'Click "Use Default Video" or upload your own video file';
    </script>
</body>
</html>
