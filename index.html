<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced Holographic Video System v2.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: crosshair;
        }
        
        canvas { 
            display: block;
            filter: contrast(1.2) brightness(1.1);
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            z-index: 100;
            text-shadow: 0 0 20px #00ffff;
            animation: pulse 1.5s infinite;
            text-align: center;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Toggle Button for Control Panel */
        #togglePanel {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 101;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, rgba(0,255,255,0.2), rgba(0,136,255,0.2));
            border: 2px solid #00ffff;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        #togglePanel:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0,255,255,0.5);
        }
        
        #togglePanel::before {
            content: '☰';
            color: #00ffff;
            font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #togglePanel.active::before {
            content: '✕';
        }
        
        /* Control Panel - Initially Hidden */
        #controlPanel {
            position: fixed;
            top: 80px;
            left: -380px; /* Hidden initially */
            z-index: 100;
            background: linear-gradient(135deg, rgba(0,20,40,0.95), rgba(0,40,80,0.95));
            border: 1px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            color: #00ffff;
            box-shadow: 0 0 30px rgba(0,255,255,0.3);
            backdrop-filter: blur(10px);
            width: 350px;
            transition: left 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        
        #controlPanel.visible {
            left: 20px;
        }
        
        #controlPanel h3 {
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        /* Quick Access Toolbar */
        #quickToolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 99;
            background: rgba(0,20,40,0.8);
            border: 1px solid #00ffff;
            border-radius: 25px;
            padding: 10px 20px;
            display: flex;
            gap: 15px;
            backdrop-filter: blur(10px);
        }
        
        .quick-btn {
            background: none;
            border: 1px solid #00ffff;
            color: #00ffff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
        }
        
        .quick-btn:hover {
            background: rgba(0,255,255,0.2);
            transform: scale(1.1);
        }
        
        .quick-btn.active {
            background: rgba(0,255,255,0.3);
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #66ffff;
        }
        
        input[type="file"] {
            width: 100%;
            padding: 8px;
            background: rgba(0,50,100,0.5);
            border: 1px solid #00ffff;
            color: #00ffff;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #00ffff, #0088ff);
            border: none;
            color: #000;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
            margin-bottom: 5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,255,255,0.5);
        }
        
        input[type="range"] {
            width: 100%;
            appearance: none;
            height: 5px;
            background: linear-gradient(90deg, #00ffff, #0088ff);
            border-radius: 5px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px #00ffff;
        }
        
        .value-display {
            float: right;
            color: #ffff00;
            font-weight: bold;
        }
        
        #stats {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #00ff00;
            font-size: 12px;
            font-family: monospace;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00ff00;
            transition: opacity 0.3s;
        }
        
        #stats.minimal {
            opacity: 0.3;
        }
        
        #stats.minimal:hover {
            opacity: 1;
        }
        
        .preset-btn {
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            margin-top: 10px;
        }
        
        #effectToggle {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }
        
        .toggle-btn {
            padding: 5px;
            font-size: 11px;
            background: rgba(0,255,255,0.2);
            border: 1px solid #00ffff;
        }
        
        .toggle-btn.active {
            background: linear-gradient(135deg, #00ffff, #0088ff);
            color: #000;
        }
        
        /* Notification System */
        .notification {
            position: fixed;
            top: 100px;
            right: -350px;
            background: linear-gradient(135deg, rgba(0,255,255,0.9), rgba(0,136,255,0.9));
            color: #000;
            padding: 15px 20px;
            border-radius: 5px;
            font-weight: bold;
            transition: right 0.5s;
            z-index: 102;
            max-width: 300px;
        }
        
        .notification.show {
            right: 20px;
        }
        
        /* Advanced Mode Indicator */
        #modeIndicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff00ff;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 10px currentColor;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        #modeIndicator.visible {
            opacity: 1;
        }
        
        /* WebXR Button */
        #xrButton {
            position: fixed;
            bottom: 80px;
            right: 20px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            border: none;
            border-radius: 25px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s;
            display: none;
        }
        
        #xrButton.available {
            display: block;
        }
        
        #xrButton:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 30px rgba(255,0,255,0.5);
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>INITIALIZING QUANTUM HOLOGRAPHIC SYSTEM...</div>
        <div style="font-size: 14px; margin-top: 10px; color: #ff00ff;">GPU ACCELERATION ENABLED</div>
    </div>
    
    <!-- Toggle Button -->
    <div id="togglePanel" title="Toggle Control Panel"></div>
    
    <!-- Mode Indicator -->
    <div id="modeIndicator">ADVANCED MODE</div>
    
    <!-- Control Panel (Initially Hidden) -->
    <div id="controlPanel">
        <h3>🎬 Quantum Holographic Control</h3>
        
        <div class="control-group">
            <input type="file" id="fileInput" accept="video/*">
            <button id="defaultVideo">Load Demo Video</button>
            <button id="testSystem">Test System</button>
        </div>
        
        <div class="control-group">
            <label>Volume <span class="value-display" id="volumeValue">50%</span></label>
            <input type="range" id="volume" min="0" max="100" value="50">
        </div>
        
        <div class="control-group">
            <label>Particle Density <span class="value-display" id="densityValue">3</span></label>
            <input type="range" id="density" min="1" max="5" value="3" step="1">
        </div>
        
        <div class="control-group">
            <label>Resolution Quality <span class="value-display" id="resolutionValue">2</span></label>
            <input type="range" id="resolution" min="1" max="4" value="2" step="1">
        </div>
        
        <div class="control-group">
            <label>Scan Lines <span class="value-display" id="scanValue">0.3</span></label>
            <input type="range" id="scanlines" min="0" max="1" value="0.3" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Glitch Intensity <span class="value-display" id="glitchValue">0.1</span></label>
            <input type="range" id="glitch" min="0" max="1" value="0.1" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Chromatic Aberration <span class="value-display" id="chromaValue">0.3</span></label>
            <input type="range" id="chroma" min="0" max="2" value="0.3" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Depth Scale <span class="value-display" id="depthValue">120</span></label>
            <input type="range" id="depth" min="0" max="300" value="120">
        </div>
        
        <div class="control-group">
            <label>Rotation Speed <span class="value-display" id="rotationValue">0.1</span></label>
            <input type="range" id="rotation" min="0" max="1" value="0.1" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Curl Noise <span class="value-display" id="curlValue">0.5</span></label>
            <input type="range" id="curl" min="0" max="2" value="0.5" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Brightness <span class="value-display" id="brightnessValue">1.2</span></label>
            <input type="range" id="brightness" min="0.5" max="2" value="1.2" step="0.1">
        </div>
        
        <button class="preset-btn" id="presetCyber">CYBER MODE</button>
        <button class="preset-btn" id="presetMatrix">MATRIX MODE</button>
        <button class="preset-btn" id="presetClean">ULTRA HD MODE</button>
        <button class="preset-btn" id="presetQuantum">QUANTUM MODE</button>
        
        <div id="effectToggle">
            <button class="toggle-btn active" data-effect="particles">Particles</button>
            <button class="toggle-btn active" data-effect="wireframe">Wireframe</button>
            <button class="toggle-btn active" data-effect="glow">Glow</button>
            <button class="toggle-btn active" data-effect="distortion">Distortion</button>
            <button class="toggle-btn active" data-effect="curl">Curl Noise</button>
            <button class="toggle-btn active" data-effect="bloom">Bloom</button>
        </div>
    </div>
    
    <!-- Quick Access Toolbar -->
    <div id="quickToolbar">
        <button class="quick-btn" id="playPause" title="Play/Pause">⏸</button>
        <button class="quick-btn" id="muteToggle" title="Mute/Unmute">🔊</button>
        <button class="quick-btn" id="fullscreen" title="Fullscreen">⛶</button>
        <button class="quick-btn" id="snapshot" title="Take Snapshot">📷</button>
        <button class="quick-btn" id="reset" title="Reset View">↻</button>
    </div>
    
    <!-- Stats Display -->
    <div id="stats" class="minimal">
        <div>FPS: <span id="fps">60</span></div>
        <div>Particles: <span id="particleCount">0</span></div>
        <div>Draw Calls: <span id="drawCalls">0</span></div>
        <div>GPU Memory: <span id="gpuMemory">0</span> MB</div>
    </div>
    
    <!-- WebXR Button -->
    <button id="xrButton">Enter VR/AR</button>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, composer;
        let hologramGroup, particles, wireframeMesh, glowMesh;
        let material, wireframeMaterial, glowMaterial;
        let video, videoTexture;
        let clock = new THREE.Clock();
        let stats = { fps: 60, lastTime: performance.now(), frames: 0 };
        let gpuCompute, velocityVariable, positionVariable;
        let isAdvancedMode = false;
        
        // Configuration with enhanced defaults
        const config = {
            density: 3,
            resolution: 2,
            scanlines: 0.3,
            glitch: 0.1,
            chroma: 0.3,
            depth: 120,
            rotation: 0.1,
            curl: 0.5,
            brightness: 1.2,
            effects: {
                particles: true,
                wireframe: true,
                glow: true,
                distortion: true,
                curl: true,
                bloom: true
            }
        };
        
        // Show notification
        function showNotification(message, duration = 3000) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    notification.remove();
                }, 500);
            }, duration);
        }
        
        // Initialize Three.js with enhanced setup
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0008);
            
            // Camera setup with better FOV
            camera = new THREE.PerspectiveCamera(
                60, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                3000
            );
            camera.position.set(0, 0, 500);
            
            // Enhanced renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp",
                stencil: false,
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);
            
            // Check for WebXR support
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        const xrButton = document.getElementById('xrButton');
                        xrButton.classList.add('available');
                        xrButton.addEventListener('click', startXR);
                    }
                });
            }
            
            // Hologram group
            hologramGroup = new THREE.Group();
            scene.add(hologramGroup);
            
            // Enhanced lighting
            setupAdvancedLighting();
            
            // Controls
            setupControls();
            
            // Event listeners
            setupEventListeners();
            
            // Background effects
            createAdvancedBackground();
            
            // Start animation
            animate();
            
            showNotification('System Initialized Successfully', 2000);
        }
        
        // Advanced lighting with dynamic colors
        function setupAdvancedLighting() {
            // Ambient light with color variation
            const ambientLight = new THREE.AmbientLight(0x0088ff, 0.15);
            scene.add(ambientLight);
            
            // Dynamic point lights
            const lightColors = [
                { color: 0x00ffff, intensity: 0.6 },
                { color: 0xff00ff, intensity: 0.4 },
                { color: 0xffff00, intensity: 0.3 },
                { color: 0x00ff00, intensity: 0.3 }
            ];
            
            lightColors.forEach((light, i) => {
                const pointLight = new THREE.PointLight(light.color, light.intensity, 800);
                const angle = (i / lightColors.length) * Math.PI * 2;
                pointLight.position.set(
                    Math.sin(angle) * 300,
                    Math.cos(angle) * 200,
                    150
                );
                scene.add(pointLight);
                
                // Animate lights
                pointLight.userData = { angle, radius: 300, speed: 0.5 + i * 0.1 };
            });
            
            // Spot light for dramatic effect
            const spotLight = new THREE.SpotLight(0x00ffff, 0.5);
            spotLight.position.set(0, 500, 500);
            spotLight.angle = Math.PI / 6;
            spotLight.penumbra = 0.3;
            spotLight.decay = 2;
            spotLight.distance = 2000;
            scene.add(spotLight);
        }
        
        // Enhanced hologram creation with GPGPU-style effects
        function createHologram(videoElement) {
            if (!videoElement) {
                console.error('Video element not ready');
                return;
            }
            
            console.log('Creating enhanced hologram...');
            
            // Clear previous hologram
            if (hologramGroup) {
                while(hologramGroup.children.length > 0) {
                    const child = hologramGroup.children[0];
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (child.material.uniforms && child.material.uniforms.video && child.material.uniforms.video.value) {
                            child.material.uniforms.video.value.dispose();
                        }
                        child.material.dispose();
                    }
                    hologramGroup.remove(child);
                }
            }
            
            // Create video texture with better settings
            videoTexture = new THREE.VideoTexture(videoElement);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.format = THREE.RGBFormat;
            videoTexture.generateMipmaps = false;
            
            // Resolution settings for better quality
            const resolutionMap = {
                1: { width: 160, height: 90 },   // Low
                2: { width: 256, height: 144 },  // Medium
                3: { width: 384, height: 216 },  // High
                4: { width: 512, height: 288 }   // Ultra
            };
            
            const densityMap = {
                1: 0.5,
                2: 0.7,
                3: 1.0,
                4: 1.3,
                5: 1.5
            };
            
            const res = resolutionMap[config.resolution];
            const densityMultiplier = densityMap[config.density];
            const width = Math.floor(res.width * densityMultiplier);
            const height = Math.floor(res.height * densityMultiplier);
            const particleCount = width * height;
            
            document.getElementById('particleCount').textContent = particleCount;
            
            // Create enhanced particle system
            if (config.effects.particles) {
                createEnhancedParticleSystem(width, height);
            }
            
            // Create high-quality wireframe
            if (config.effects.wireframe) {
                createEnhancedWireframe(width, height);
            }
            
            // Create advanced glow effect
            if (config.effects.glow) {
                createAdvancedGlowEffect();
            }
            
            document.getElementById('loading').style.display = 'none';
            showNotification('Hologram Loaded Successfully', 2000);
        }
        
        // Enhanced particle system with curl noise simulation
        function createEnhancedParticleSystem(width, height) {
            const particleCount = width * height;
            const geometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(particleCount * 3);
            const uvs = new Float32Array(particleCount * 2);
            const indices = new Float32Array(particleCount);
            const randoms = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < width; i++) {
                for (let j = 0; j < height; j++) {
                    const index = j * width + i;
                    
                    positions[index * 3] = (i / width - 0.5) * 400;
                    positions[index * 3 + 1] = (j / height - 0.5) * 225;
                    positions[index * 3 + 2] = 0;
                    
                    uvs[index * 2] = i / (width - 1);
                    uvs[index * 2 + 1] = j / (height - 1);
                    
                    indices[index] = index;
                    
                    randoms[index * 3] = Math.random();
                    randoms[index * 3 + 1] = Math.random();
                    randoms[index * 3 + 2] = Math.random();
                }
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            geometry.setAttribute('index', new THREE.BufferAttribute(indices, 1));
            geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 3));
            
            // Enhanced holographic shader with curl noise
            material = new THREE.ShaderMaterial({
                uniforms: {
                    video: { value: videoTexture },
                    time: { value: 0 },
                    depthScale: { value: config.depth },
                    scanlines: { value: config.scanlines },
                    glitchIntensity: { value: config.glitch },
                    chromaticAberration: { value: config.chroma },
                    distortion: { value: config.effects.distortion ? 1.0 : 0.0 },
                    curlIntensity: { value: config.curl },
                    brightness: { value: config.brightness },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    mousePosition: { value: new THREE.Vector2(0, 0) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vColor;
                    varying float vDepth;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    uniform sampler2D video;
                    uniform float time;
                    uniform float depthScale;
                    uniform float distortion;
                    uniform float curlIntensity;
                    uniform vec2 mousePosition;
                    
                    attribute float index;
                    attribute vec3 random;
                    
                    // Improved noise functions
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    
                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        
                        vec3 i = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        
                        i = mod289(i);
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        
                        vec3 p0 = vec3(a0.xy, h.x);
                        vec3 p1 = vec3(a0.zw, h.y);
                        vec3 p2 = vec3(a1.xy, h.z);
                        vec3 p3 = vec3(a1.zw, h.w);
                        
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;
                        
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }
                    
                    // Curl noise implementation
                    vec3 curlNoise(vec3 p) {
                        float epsilon = 0.01;
                        vec3 dx = vec3(epsilon, 0.0, 0.0);
                        vec3 dy = vec3(0.0, epsilon, 0.0);
                        vec3 dz = vec3(0.0, 0.0, epsilon);
                        
                        vec3 p_x0 = vec3(snoise(p - dx), snoise(p - dy), snoise(p - dz));
                        vec3 p_x1 = vec3(snoise(p + dx), snoise(p + dy), snoise(p + dz));
                        
                        return normalize(p_x1 - p_x0);
                    }
                    
                    void main() {
                        vUv = uv;
                        vec4 color = texture2D(video, uv);
                        vColor = color.rgb;
                        
                        // Enhanced luminance calculation
                        float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                        luminance = pow(luminance, 0.8); // Gamma correction for better depth
                        vDepth = luminance;
                        
                        vec3 pos = position;
                        
                        // High-quality depth mapping
                        float depthOffset = -luminance * depthScale;
                        pos.z = depthOffset;
                        
                        // Curl noise displacement
                        if (curlIntensity > 0.0) {
                            vec3 curlOffset = curlNoise(vec3(uv * 10.0, time * 0.5));
                            pos += curlOffset * curlIntensity * 20.0 * luminance;
                        }
                        
                        // Advanced wave distortion
                        float wave1 = sin(uv.x * 15.0 + time * 2.0) * cos(uv.y * 15.0 + time * 1.5);
                        float wave2 = sin(uv.x * 7.0 - time * 1.5) * cos(uv.y * 9.0 + time * 2.0);
                        pos.z += (wave1 + wave2 * 0.5) * 3.0 * distortion;
                        
                        // Simplex noise displacement
                        vec3 noisePos = vec3(uv * 8.0, time * 0.3);
                        float n = snoise(noisePos);
                        pos.xy += vec2(n) * 5.0 * distortion;
                        
                        // Mouse interaction
                        float mouseDistance = distance(uv, mousePosition);
                        float mouseEffect = smoothstep(0.3, 0.0, mouseDistance);
                        pos.z += mouseEffect * 30.0;
                        
                        // Pulsing with variation
                        float pulse = sin(time * 3.0 + index * 0.001 + random.x * 6.28) * 0.5 + 0.5;
                        pos.z += pulse * 3.0 * random.y;
                        
                        // Spiral motion
                        float spiralAngle = time * 0.5 + random.z * 6.28;
                        pos.x += sin(spiralAngle) * random.x * 5.0;
                        pos.y += cos(spiralAngle) * random.y * 5.0;
                        
                        vPosition = pos;
                        vNormal = normalize(vec3(n, n * 0.5, 1.0));
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        
                        // Advanced point sizing
                        float size = mix(1.5, 4.0, luminance);
                        size *= (1.0 + pulse * 0.3);
                        size *= (1.0 + mouseEffect * 0.5);
                        size = max(size, 1.0);
                        gl_PointSize = size;
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    varying vec3 vColor;
                    varying float vDepth;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    uniform float time;
                    uniform float scanlines;
                    uniform float glitchIntensity;
                    uniform float chromaticAberration;
                    uniform float brightness;
                    uniform vec2 resolution;
                    
                    // Hash function for randomness
                    float hash(vec2 p) {
                        vec3 p3 = fract(vec3(p.xyx) * 0.13);
                        p3 += dot(p3, p3.yzx + 3.333);
                        return fract((p3.x + p3.y) * p3.z);
                    }
                    
                    // Film grain
                    float grain(vec2 uv, float t) {
                        return hash(uv + t) * 0.05;
                    }
                    
                    void main() {
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        float dist = length(coord);
                        
                        // Smooth circular points with antialiasing
                        float alpha = 1.0 - smoothstep(0.45, 0.5, dist);
                        if(alpha < 0.01) discard;
                        
                        vec3 color = vColor;
                        
                        // Enhanced chromatic aberration
                        if (chromaticAberration > 0.0) {
                            float aberration = chromaticAberration * 0.01 * (1.0 + sin(time * 2.0) * 0.2);
                            color.r = texture2D(video, vUv + vec2(aberration, 0.0)).r;
                            color.g = vColor.g;
                            color.b = texture2D(video, vUv - vec2(aberration, 0.0)).b;
                        }
                        
                        // Advanced holographic color shift
                        float holo1 = sin(vPosition.x * 0.05 + time) * 0.5 + 0.5;
                        float holo2 = cos(vPosition.y * 0.05 - time * 0.7) * 0.5 + 0.5;
                        vec3 holoColor = mix(
                            vec3(0.0, 1.0, 1.0),
                            vec3(1.0, 0.0, 1.0),
                            holo1
                        );
                        color = mix(color, holoColor, holo2 * 0.2);
                        
                        // High-quality scanlines
                        if (scanlines > 0.0) {
                            float scanline = sin(gl_FragCoord.y * 0.7 + time * 10.0) * 0.04 + 
                                           sin(gl_FragCoord.y * 1.3 + time * 15.0) * 0.02;
                            scanline = 1.0 + scanline * scanlines;
                            color *= scanline;
                        }
                        
                        // Improved glitch effect
                        if (glitchIntensity > 0.0) {
                            float glitchTime = floor(time * 10.0) / 10.0;
                            float glitch = hash(vec2(glitchTime, vUv.y));
                            
                            if(glitch < glitchIntensity * 0.05) {
                                color.rgb = vec3(1.0 - color.r, color.g, 1.0 - color.b);
                                color = mix(color, vec3(hash(vUv + time)), 0.1);
                            }
                            
                            // Digital artifact lines
                            if(hash(vec2(time * 0.1, floor(vUv.y * 100.0))) < glitchIntensity * 0.02) {
                                color = vec3(1.0, 0.0, 1.0);
                            }
                        }
                        
                        // Advanced edge glow with color
                        float edgeFactor = 1.0 - dist * 2.0;
                        vec3 edgeGlow = mix(
                            vec3(0.0, 1.0, 1.0),
                            vec3(1.0, 0.0, 1.0),
                            sin(time * 3.0 + vPosition.x * 0.01) * 0.5 + 0.5
                        );
                        color += edgeGlow * pow(edgeFactor, 3.0) * 0.5;
                        
                        // Depth-based brightness with better falloff
                        float depthBrightness = 0.6 + vDepth * 0.6;
                        depthBrightness = pow(depthBrightness, 0.8);
                        color *= depthBrightness * brightness;
                        
                        // Fresnel effect
                        float fresnel = pow(1.0 - abs(dot(normalize(vNormal), vec3(0.0, 0.0, 1.0))), 2.0);
                        color += vec3(0.2, 0.6, 1.0) * fresnel * 0.3;
                        
                        // Film grain for texture
                        color += vec3(grain(gl_FragCoord.xy, time)) * 0.5;
                        
                        // Subtle flickering
                        float flicker = sin(time * 60.0 + hash(vUv) * 100.0) * 0.03 + 0.97;
                        color *= flicker;
                        
                        // Color grading
                        color = pow(color, vec3(0.9)); // Slight gamma adjustment
                        color = mix(color, vec3(dot(color, vec3(0.299, 0.587, 0.114))), -0.1); // Slight saturation boost
                        
                        // Final alpha with smooth falloff
                        alpha *= 0.85 + vDepth * 0.15;
                        alpha *= pow(edgeFactor, 0.5);
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: true
            });
            
            particles = new THREE.Points(geometry, material);
            hologramGroup.add(particles);
        }
        
        // Enhanced wireframe with better quality
        function createEnhancedWireframe(width, height) {
            const geometry = new THREE.PlaneGeometry(400, 225, Math.floor(width/3), Math.floor(height/3));
            
            wireframeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    video: { value: videoTexture },
                    time: { value: 0 },
                    depthScale: { value: config.depth },
                    brightness: { value: config.brightness }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying float vDepth;
                    
                    uniform sampler2D video;
                    uniform float depthScale;
                    uniform float time;
                    
                    void main() {
                        vUv = uv;
                        vec4 color = texture2D(video, uv);
                        float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                        vDepth = pow(luminance, 0.8);
                        
                        vec3 pos = position;
                        pos.z = -vDepth * depthScale * 0.5;
                        
                        // Smooth wave effect
                        pos.z += sin(pos.x * 0.03 + time) * 5.0;
                        pos.z += cos(pos.y * 0.03 + time * 0.7) * 5.0;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    varying float vDepth;
                    
                    uniform float time;
                    uniform float brightness;
                    
                    void main() {
                        vec3 color = mix(
                            vec3(0.0, 1.0, 1.0),
                            vec3(0.0, 0.5, 1.0),
                            sin(time * 2.0 + vUv.x * 10.0) * 0.5 + 0.5
                        );
                        
                        float alpha = 0.05 + vDepth * 0.15;
                        alpha *= 0.8 + sin(time * 5.0) * 0.2;
                        alpha *= brightness * 0.8;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                wireframe: true,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);
            hologramGroup.add(wireframeMesh);
        }
        
        // Advanced glow effect with multiple layers
        function createAdvancedGlowEffect() {
            // Create multiple glow layers for depth
            const glowLayers = [
                { size: 500, distance: -150, intensity: 0.3, color: 0x00ffff },
                { size: 550, distance: -200, intensity: 0.2, color: 0xff00ff },
                { size: 600, distance: -250, intensity: 0.1, color: 0x0088ff }
            ];
            
            glowLayers.forEach((layer, index) => {
                const geometry = new THREE.PlaneGeometry(layer.size, layer.size * 0.56);
                
                const glowMat = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        color: { value: new THREE.Color(layer.color) },
                        intensity: { value: layer.intensity }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec2 vUv;
                        uniform float time;
                        uniform vec3 color;
                        uniform float intensity;
                        
                        void main() {
                            vec2 center = vec2(0.5, 0.5);
                            float dist = distance(vUv, center);
                            
                            float glow = 1.0 - smoothstep(0.0, 0.7, dist);
                            glow = pow(glow, 3.0);
                            
                            vec3 finalColor = color * glow;
                            
                            float pulse = sin(time * 2.0 + float(${index}) * 1.57) * 0.5 + 0.5;
                            float alpha = glow * intensity * (0.7 + pulse * 0.3);
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });
                
                const glowPlane = new THREE.Mesh(geometry, glowMat);
                glowPlane.position.z = layer.distance;
                glowPlane.userData = { material: glowMat };
                hologramGroup.add(glowPlane);
            });
        }
        
        // Create advanced background
        function createAdvancedBackground() {
            // Dynamic grid
            const gridHelper = new THREE.GridHelper(3000, 60, 0x00ffff, 0x003366);
            gridHelper.position.y = -250;
            scene.add(gridHelper);
            
            // Floating particles
            const particleCount = 1000;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleSizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                particlePositions[i * 3] = (Math.random() - 0.5) * 2000;
                particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
                particleSizes[i] = Math.random() * 3 + 1;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
            
            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(0x00ffff) }
                },
                vertexShader: `
                    attribute float size;
                    varying float vSize;
                    uniform float time;
                    
                    void main() {
                        vSize = size;
                        vec3 pos = position;
                        pos.y += sin(time + position.x * 0.01) * 20.0;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float time;
                    varying float vSize;
                    
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.45, 0.5, dist);
                        alpha *= 0.5 + sin(time * 2.0 + vSize) * 0.5;
                        
                        gl_FragColor = vec4(color, alpha * 0.6);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const backgroundParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(backgroundParticles);
            
            // Store for animation
            window.backgroundElements = {
                grid: gridHelper,
                particles: backgroundParticles,
                particleMaterial: particleMaterial
            };
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const delta = clock.getDelta();
            
            // Update materials
            if (material) {
                material.uniforms.time.value = time;
                material.uniforms.depthScale.value = config.depth;
                material.uniforms.scanlines.value = config.scanlines;
                material.uniforms.glitchIntensity.value = config.glitch;
                material.uniforms.chromaticAberration.value = config.chroma;
                material.uniforms.distortion.value = config.effects.distortion ? 1.0 : 0.0;
                material.uniforms.curlIntensity.value = config.effects.curl ? config.curl : 0.0;
                material.uniforms.brightness.value = config.brightness;
            }
            
            if (wireframeMaterial) {
                wireframeMaterial.uniforms.time.value = time;
                wireframeMaterial.uniforms.depthScale.value = config.depth;
                wireframeMaterial.uniforms.brightness.value = config.brightness;
            }
            
            // Update glow layers
            hologramGroup.children.forEach(child => {
                if (child.userData.material) {
                    child.userData.material.uniforms.time.value = time;
                }
            });
            
            // Rotate hologram
            if (hologramGroup && config.rotation > 0) {
                hologramGroup.rotation.y += config.rotation * 0.01;
            }
            
            // Animate lights
            scene.children.forEach(child => {
                if (child.isPointLight && child.userData.angle !== undefined) {
                    const userData = child.userData;
                    userData.angle += userData.speed * delta;
                    child.position.x = Math.sin(userData.angle) * userData.radius;
                    child.position.z = Math.cos(userData.angle) * userData.radius;
                }
            });
            
            // Animate background
            if (window.backgroundElements) {
                window.backgroundElements.particles.rotation.y += 0.0003;
                window.backgroundElements.particles.rotation.x += 0.0001;
                window.backgroundElements.particleMaterial.uniforms.time.value = time;
            }
            
            // Update camera
            if (window.updateCamera) {
                window.updateCamera();
            }
            
            // Update stats
            updateStats();
            
            // Render
            renderer.render(scene, camera);
        }
        
        // Mouse controls with smoothing
        function setupControls() {
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX - window.innerWidth / 2) / window.innerWidth;
                mouseY = (e.clientY - window.innerHeight / 2) / window.innerHeight;
                
                // Update shader mouse position
                if (material) {
                    material.uniforms.mousePosition.value.x = e.clientX / window.innerWidth;
                    material.uniforms.mousePosition.value.y = 1.0 - (e.clientY / window.innerHeight);
                }
            });
            
            // Smooth camera movement
            function updateCamera() {
                targetX += (mouseX - targetX) * 0.02;
                targetY += (mouseY - targetY) * 0.02;
                
                camera.position.x = targetX * 150;
                camera.position.y = -targetY * 150;
                camera.lookAt(scene.position);
            }
            
            // Mouse wheel zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.5;
                camera.position.z = Math.max(200, Math.min(1000, camera.position.z));
            });
            
            window.updateCamera = updateCamera;
        }
        
        // Create test video
        function createTestVideo() {
            console.log('Creating enhanced test video...');
            
            const canvas = document.createElement('canvas');
            canvas.width = 1280;
            canvas.height = 720;
            const ctx = canvas.getContext('2d');
            
            let frame = 0;
            
            function drawFrame() {
                frame++;
                const time = frame * 0.02;
                
                // Gradient background
                const gradient = ctx.createRadialGradient(
                    canvas.width/2, canvas.height/2, 0,
                    canvas.width/2, canvas.height/2, canvas.width/2
                );
                gradient.addColorStop(0, `hsl(${(time * 20) % 360}, 100%, 20%)`);
                gradient.addColorStop(0.5, `hsl(${(time * 20 + 120) % 360}, 100%, 15%)`);
                gradient.addColorStop(1, '#000011');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Multiple animated elements
                for (let i = 0; i < 8; i++) {
                    const x = (canvas.width / 2) + Math.sin(time + i * 0.8) * 250;
                    const y = (canvas.height / 2) + Math.cos(time * 0.7 + i * 0.8) * 150;
                    const radius = 30 + Math.sin(time * 2 + i) * 15;
                    
                    const circleGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    circleGradient.addColorStop(0, `hsla(${(time * 50 + i * 45) % 360}, 100%, 70%, 0.8)`);
                    circleGradient.addColorStop(1, `hsla(${(time * 50 + i * 45) % 360}, 100%, 30%, 0.2)`);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = circleGradient;
                    ctx.fill();
                }
                
                // Text with glow
                ctx.save();
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 30;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 64px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('QUANTUM HOLOGRAM', canvas.width / 2, canvas.height / 2);
                
                ctx.font = '24px monospace';
                ctx.fillStyle = '#00ffff';
                ctx.fillText('Enhanced Reality System v2.0', canvas.width / 2, canvas.height / 2 + 50);
                ctx.restore();
                
                // Grid overlay
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.1 + Math.sin(time * 3) * 0.05})`;
                ctx.lineWidth = 1;
                for (let x = 0; x < canvas.width; x += 40) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < canvas.height; y += 40) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                requestAnimationFrame(drawFrame);
            }
            
            drawFrame();
            
            // Create video from canvas
            const stream = canvas.captureStream(30);
            
            if (video) {
                video.pause();
                video.remove();
            }
            
            video = document.createElement('video');
            video.srcObject = stream;
            video.loop = true;
            video.muted = true;
            video.style.display = 'none';
            document.body.appendChild(video);
            
            video.play().then(() => {
                createHologram(video);
            }).catch(err => {
                console.error('Failed to play test video:', err);
            });
        }
        
        // Setup video
        function setupVideo(src) {
            console.log('Setting up video:', src);
            
            if (video) {
                video.pause();
                video.remove();
            }
            
            video = document.createElement('video');
            video.crossOrigin = 'anonymous';
            video.loop = true;
            video.muted = false;
            video.playsInline = true;
            video.volume = document.getElementById('volume').value / 100;
            video.style.display = 'none';
            
            document.body.appendChild(video);
            
            video.addEventListener('canplay', () => {
                video.play().then(() => {
                    createHologram(video);
                }).catch(() => {
                    document.getElementById('loading').textContent = 'CLICK TO START';
                    document.addEventListener('click', () => {
                        video.play().then(() => {
                            createHologram(video);
                        });
                    }, { once: true });
                });
            });
            
            video.src = src;
            video.load();
        }
        
        // Update stats
        function updateStats() {
            stats.frames++;
            const currentTime = performance.now();
            if (currentTime >= stats.lastTime + 1000) {
                stats.fps = Math.round(stats.frames * 1000 / (currentTime - stats.lastTime));
                document.getElementById('fps').textContent = stats.fps;
                stats.lastTime = currentTime;
                stats.frames = 0;
                
                if (renderer.info) {
                    document.getElementById('drawCalls').textContent = renderer.info.render.calls || 0;
                    const memory = (renderer.info.memory.geometries + renderer.info.memory.textures) || 0;
                    document.getElementById('gpuMemory').textContent = memory.toFixed(1);
                }
            }
        }
        
        // Apply preset
        function applyPreset(preset) {
            Object.keys(preset).forEach(key => {
                if (config.hasOwnProperty(key)) {
                    config[key] = preset[key];
                    const slider = document.getElementById(key);
                    if (slider) {
                        slider.value = preset[key];
                        const valueDisplay = document.getElementById(slider.id + 'Value');
                        if (valueDisplay) {
                            valueDisplay.textContent = preset[key];
                        }
                    }
                }
            });
            
            if (video && video.readyState >= 2) {
                createHologram(video);
            }
            
            showNotification(`Preset Applied: ${preset.name || 'Custom'}`, 2000);
        }
        
        // WebXR support
        async function startXR() {
            if (!navigator.xr) return;
            
            try {
                const session = await navigator.xr.requestSession('immersive-vr');
                renderer.xr.enabled = true;
                renderer.xr.setSession(session);
                
                showNotification('Entering VR Mode', 2000);
            } catch (err) {
                console.error('XR session failed:', err);
                showNotification('VR not available', 3000);
            }
        }
        
        // Snapshot function
        function takeSnapshot() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            
            const link = document.createElement('a');
            link.download = `hologram-snapshot-${Date.now()}.png`;
            link.href = dataURL;
            link.click();
            
            showNotification('Snapshot saved!', 2000);
        }
        
        // Setup all event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                if (material) {
                    material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                }
            });
            
            // Toggle panel
            const toggleBtn = document.getElementById('togglePanel');
            const controlPanel = document.getElementById('controlPanel');
            
            toggleBtn.addEventListener('click', () => {
                controlPanel.classList.toggle('visible');
                toggleBtn.classList.toggle('active');
                
                const isVisible = controlPanel.classList.contains('visible');
                showNotification(isVisible ? 'Control Panel Opened' : 'Control Panel Closed', 1500);
            });
            
            // File input
            document.getElementById('fileInput').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('video/')) {
                    document.getElementById('loading').style.display = 'block';
                    document.getElementById('loading').innerHTML = 
                        '<div>LOADING VIDEO...</div>' +
                        '<div style="font-size: 14px; margin-top: 10px;">Processing: ' + file.name + '</div>';
                    
                    const url = URL.createObjectURL(file);
                    setupVideo(url);
                }
            });
            
            // Demo video button
            document.getElementById('defaultVideo').addEventListener('click', () => {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = 
                    '<div>GENERATING DEMO...</div>' +
                    '<div style="font-size: 14px; margin-top: 10px;">Creating Quantum Patterns</div>';
                createTestVideo();
            });
            
            // Test system button
            document.getElementById('testSystem').addEventListener('click', () => {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').innerHTML = 
                    '<div>SYSTEM DIAGNOSTICS</div>' +
                    '<div style="font-size: 14px; margin-top: 10px;">Running Performance Test</div>';
                
                // Run performance test
                const testCanvas = document.createElement('canvas');
                testCanvas.width = 1920;
                testCanvas.height = 1080;
                const ctx = testCanvas.getContext('2d');
                
                function drawTestPattern() {
                    const time = Date.now() * 0.001;
                    
                    // Create complex gradient
                    const gradient = ctx.createConicGradient(0, testCanvas.width/2, testCanvas.height/2);
                    for (let i = 0; i < 12; i++) {
                        gradient.addColorStop(i/12, `hsl(${(time * 50 + i * 30) % 360}, 100%, 50%)`);
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, testCanvas.width, testCanvas.height);
                    
                    // Test pattern
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 72px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('SYSTEM TEST', testCanvas.width/2, testCanvas.height/2);
                    
                    ctx.font = '36px monospace';
                    ctx.fillText(`GPU: ${renderer.capabilities.maxTextures} textures`, testCanvas.width/2, testCanvas.height/2 + 60);
                    ctx.fillText(`Resolution: ${testCanvas.width}x${testCanvas.height}`, testCanvas.width/2, testCanvas.height/2 + 100);
                    
                    requestAnimationFrame(drawTestPattern);
                }
                
                drawTestPattern();
                
                const stream = testCanvas.captureStream(60);
                const testVideo = document.createElement('video');
                testVideo.srcObject = stream;
                testVideo.loop = true;
                testVideo.muted = true;
                testVideo.play();
                
                setTimeout(() => {
                    createHologram(testVideo);
                    showNotification('System Test Complete - All Systems Operational', 3000);
                }, 500);
            });
            
            // Sliders
            document.getElementById('volume').addEventListener('input', (e) => {
                const volume = e.target.value;
                document.getElementById('volumeValue').textContent = volume + '%';
                if (video) {
                    video.volume = volume / 100;
                    video.muted = volume == 0;
                }
            });
            
            document.getElementById('density').addEventListener('input', (e) => {
                config.density = parseInt(e.target.value);
                document.getElementById('densityValue').textContent = config.density;
                if (video && video.readyState >= 2) {
                    createHologram(video);
                }
            });
            
            document.getElementById('resolution').addEventListener('input', (e) => {
                config.resolution = parseInt(e.target.value);
                document.getElementById('resolutionValue').textContent = config.resolution;
                if (video && video.readyState >= 2) {
                    createHologram(video);
                }
            });
            
            document.getElementById('scanlines').addEventListener('input', (e) => {
                config.scanlines = parseFloat(e.target.value);
                document.getElementById('scanValue').textContent = config.scanlines;
            });
            
            document.getElementById('glitch').addEventListener('input', (e) => {
                config.glitch = parseFloat(e.target.value);
                document.getElementById('glitchValue').textContent = config.glitch;
            });
            
            document.getElementById('chroma').addEventListener('input', (e) => {
                config.chroma = parseFloat(e.target.value);
                document.getElementById('chromaValue').textContent = config.chroma;
            });
            
            document.getElementById('depth').addEventListener('input', (e) => {
                config.depth = parseFloat(e.target.value);
                document.getElementById('depthValue').textContent = config.depth;
            });
            
            document.getElementById('rotation').addEventListener('input', (e) => {
                config.rotation = parseFloat(e.target.value);
                document.getElementById('rotationValue').textContent = config.rotation;
            });
            
            document.getElementById('curl').addEventListener('input', (e) => {
                config.curl = parseFloat(e.target.value);
                document.getElementById('curlValue').textContent = config.curl;
            });
            
            document.getElementById('brightness').addEventListener('input', (e) => {
                config.brightness = parseFloat(e.target.value);
                document.getElementById('brightnessValue').textContent = config.brightness;
            });
            
            // Presets
            document.getElementById('presetCyber').addEventListener('click', () => {
                applyPreset({
                    name: 'Cyber Mode',
                    density: 4, 
                    resolution: 3,
                    scanlines: 0.8, 
                    glitch: 0.5,
                    chroma: 1.5, 
                    depth: 200, 
                    rotation: 0.3,
                    curl: 1.0,
                    brightness: 1.5
                });
                document.getElementById('modeIndicator').textContent = 'CYBER MODE';
                document.getElementById('modeIndicator').classList.add('visible');
                setTimeout(() => {
                    document.getElementById('modeIndicator').classList.remove('visible');
                }, 3000);
            });
            
            document.getElementById('presetMatrix').addEventListener('click', () => {
                applyPreset({
                    name: 'Matrix Mode',
                    density: 5, 
                    resolution: 2,
                    scanlines: 1.0, 
                    glitch: 0.7,
                    chroma: 0.3, 
                    depth: 250, 
                    rotation: 0.1,
                    curl: 0.3,
                    brightness: 0.8
                });
                document.getElementById('modeIndicator').textContent = 'MATRIX MODE';
                document.getElementById('modeIndicator').classList.add('visible');
                setTimeout(() => {
                    document.getElementById('modeIndicator').classList.remove('visible');
                }, 3000);
            });
            
            document.getElementById('presetClean').addEventListener('click', () => {
                applyPreset({
                    name: 'Ultra HD Mode',
                    density: 4, 
                    resolution: 4,
                    scanlines: 0, 
                    glitch: 0,
                    chroma: 0, 
                    depth: 100, 
                    rotation: 0.2,
                    curl: 0.2,
                    brightness: 1.3
                });
                document.getElementById('modeIndicator').textContent = 'ULTRA HD MODE';
                document.getElementById('modeIndicator').classList.add('visible');
                setTimeout(() => {
                    document.getElementById('modeIndicator').classList.remove('visible');
                }, 3000);
            });
            
            document.getElementById('presetQuantum').addEventListener('click', () => {
                applyPreset({
                    name: 'Quantum Mode',
                    density: 5, 
                    resolution: 3,
                    scanlines: 0.3, 
                    glitch: 0.2,
                    chroma: 0.8, 
                    depth: 180, 
                    rotation: 0.15,
                    curl: 1.5,
                    brightness: 1.4
                });
                document.getElementById('modeIndicator').textContent = 'QUANTUM MODE';
                document.getElementById('modeIndicator').classList.add('visible');
                setTimeout(() => {
                    document.getElementById('modeIndicator').classList.remove('visible');
                }, 3000);
            });
            
            // Effect toggles
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const effect = e.target.dataset.effect;
                    config.effects[effect] = !config.effects[effect];
                    e.target.classList.toggle('active');
                    
                    switch(effect) {
                        case 'particles': 
                            if (particles) particles.visible = config.effects.particles; 
                            break;
                        case 'wireframe': 
                            if (wireframeMesh) wireframeMesh.visible = config.effects.wireframe; 
                            break;
                        case 'glow': 
                            hologramGroup.children.forEach(child => {
                                if (child.userData.material) {
                                    child.visible = config.effects.glow;
                                }
                            });
                            break;
                        case 'curl':
                        case 'distortion':
                        case 'bloom':
                            // These are handled in the shader
                            if (video && video.readyState >= 2) {
                                createHologram(video);
                            }
                            break;
                    }
                    
                    showNotification(`${effect.charAt(0).toUpperCase() + effect.slice(1)} ${config.effects[effect] ? 'Enabled' : 'Disabled'}`, 1500);
                });
            });
            
            // Quick toolbar buttons
            document.getElementById('playPause').addEventListener('click', () => {
                if (video) {
                    if (video.paused) {
                        video.play();
                        document.getElementById('playPause').textContent = '⏸';
                        showNotification('Playing', 1000);
                    } else {
                        video.pause();
                        document.getElementById('playPause').textContent = '▶';
                        showNotification('Paused', 1000);
                    }
                }
            });
            
            document.getElementById('muteToggle').addEventListener('click', () => {
                if (video) {
                    video.muted = !video.muted;
                    document.getElementById('muteToggle').textContent = video.muted ? '🔇' : '🔊';
                    showNotification(video.muted ? 'Muted' : 'Unmuted', 1000);
                }
            });
            
            document.getElementById('fullscreen').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                    showNotification('Fullscreen Mode', 1500);
                } else {
                    document.exitFullscreen();
                }
            });
            
            document.getElementById('snapshot').addEventListener('click', takeSnapshot);
            
            document.getElementById('reset').addEventListener('click', () => {
                camera.position.set(0, 0, 500);
                camera.lookAt(scene.position);
                hologramGroup.rotation.set(0, 0, 0);
                showNotification('View Reset', 1500);
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case ' ':
                        if (video) {
                            if (video.paused) {
                                video.play();
                                document.getElementById('playPause').textContent = '⏸';
                            } else {
                                video.pause();
                                document.getElementById('playPause').textContent = '▶';
                            }
                        }
                        e.preventDefault();
                        break;
                    case 'h':
                    case 'H':
                        controlPanel.classList.toggle('visible');
                        toggleBtn.classList.toggle('active');
                        break;
                    case 'r':
                    case 'R':
                        config.rotation = config.rotation > 0 ? 0 : 0.2;
                        document.getElementById('rotation').value = config.rotation;
                        document.getElementById('rotationValue').textContent = config.rotation;
                        break;
                    case 'f':
                    case 'F':
                        if (!document.fullscreenElement) {
                            document.documentElement.requestFullscreen();
                        } else {
                            document.exitFullscreen();
                        }
                        break;
                    case 's':
                    case 'S':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            takeSnapshot();
                        }
                        break;
                    case '1':
                        document.getElementById('presetCyber').click();
                        break;
                    case '2':
                        document.getElementById('presetMatrix').click();
                        break;
                    case '3':
                        document.getElementById('presetClean').click();
                        break;
                    case '4':
                        document.getElementById('presetQuantum').click();
                        break;
                }
            });
            
            // Double-click to toggle panel
            document.addEventListener('dblclick', () => {
                controlPanel.classList.toggle('visible');
                toggleBtn.classList.toggle('active');
            });
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing Enhanced Holographic System v2.0...');
            
            try {
                init();
                
                setTimeout(() => {
                    document.getElementById('loading').innerHTML = 
                        '<div>SYSTEM READY</div>' +
                        '<div style="font-size: 14px; margin-top: 10px;">Load a video or use demo</div>' +
                        '<div style="font-size: 12px; margin-top: 10px; color: #ff00ff;">Press H to toggle controls</div>';
                }, 1500);
                
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('loading').innerHTML = 
                    '<div>ERROR</div>' +
                    '<div style="font-size: 14px; margin-top: 10px; color: #ff0000;">' + error.message + '</div>';
            }
        });
    </script>
</body>
</html> p = permute(permute(permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                            
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        
                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        
                        vec4
